@using System.Threading
@using System.Threading.Tasks
@using WorkTimeApp.Shared.Model
@using WorkTimeApp.Shared.Services

@inject NavigationManager Navigation
@inject ApiService ApiService

<div class="task-list-container">
    @foreach (TaskModel task in FilteredTasks.OrderByDescending(o => o.Priority))
    {
        <div class="task-card">
            <div class="task-header">
                <h4>@task.Title</h4>
                <span class="badge bg-primary">priorytet: @task.Priority</span>
                <span class="badge @(task.Status == EnumStatus.Completed ? "bg-success" : (task.Status == EnumStatus.Active ? "bg-warning" : "bg-secondary"))">
                    @(task.Status == EnumStatus.Completed ? "Zakończony" : (task.Status == EnumStatus.Active ? "Aktywny" : "Nie zakończony"))
                </span>
            </div>
            <div class="task-body">
                <small class="text-muted">Termin: @(task.DueDate is DateTime dt ? dt.ToString("dd-MM-yyyy") : "")</small>
                <br />
                <small class="text-muted">
                    Czas: @GetLiveTime(task)
                </small>
            </div>
            <div class="task-footer">
                @if (task.Status == EnumStatus.InComplete)
                {
                    <button class="btn-action edit" @onclick="() => EditTask(task.Id)">
                        <i class="bi bi-pencil"></i>
                    </button>
                    <button class="btn-action start" @onclick="() => StartTask(task)">
                        <i class="bi bi-play-fill"></i>
                    </button>
                    <button class="btn-action complete" @onclick="() => CompleteTask(task)">
                        <i class="bi bi-check2-circle"></i>
                    </button>
                }
                @if (task.Status == EnumStatus.Active)
                {
                    <button class="btn-action stop" @onclick="() => StopTask(task)">
                        <i class="bi bi-stop-fill"></i>
                    </button>
                }
                <button class="btn-action history" @onclick="() => TaskHistory(task.Id)">
                    <i class="bi bi-clock-history"></i>
                </button>
            </div>
        </div>
    }
</div>

<link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" rel="stylesheet">

<style>
    /* Twój CSS bez zmian */
    .task-list-container {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
        gap: 16px;
        margin-top: 20px;
    }

    .task-card {
        background: #fff;
        border-radius: 10px;
        padding: 16px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        transition: transform 0.2s;
    }

        .task-card:hover {
            transform: translateY(-3px);
        }

    .task-header {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 10px;
    }

        .task-header h4 {
            flex-grow: 1;
            font-size: 1.2rem;
            margin: 0;
        }

    .task-body {
        margin-bottom: 12px;
        font-size: 0.95rem;
        color: #555;
    }

    .task-footer {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
    }

    .btn-action {
        background: none;
        border: none;
        font-size: 1.3rem;
        cursor: pointer;
        padding: 6px;
        border-radius: 8px;
        transition: background 0.2s, transform 0.1s;
    }

        .btn-action:hover {
            transform: scale(1.1);
        }

        .btn-action.edit:hover {
            background: #e3f2fd;
            color: #1976d2;
        }

        .btn-action.start:hover {
            background: #e8f5e9;
            color: #388e3c;
        }

        .btn-action.stop:hover {
            background: #fff3e0;
            color: #f57c00;
        }

        .btn-action.complete:hover {
            background: #e3f2fd;
            color: #1976d2;
        }

        .btn-action.history:hover {
            background: #ede7f6;
            color: #512da8;
        }
</style>

@code {
    [Parameter]
    public int Userid { get; set; }

    [Parameter]
    public string Filter { get; set; } = string.Empty;

    [Parameter]
    public List<TaskModel> tasks { get; set; } = new();

    [Parameter]
    public Func<TaskModel, bool>? FilterFunc { get; set; }

    private IEnumerable<TaskModel> FilteredTasks =>
        FilterFunc is null ? tasks : tasks.Where(FilterFunc);

    private CancellationTokenSource? cts;

    protected override async Task OnInitializedAsync()
    {
        cts = new CancellationTokenSource();
        var periodicTimer = new PeriodicTimer(TimeSpan.FromSeconds(1));

        try
        {
            while (await periodicTimer.WaitForNextTickAsync(cts.Token))
            {
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (OperationCanceledException)
        {
            // Timer anulowany - nic nie robimy
        }
    }

    private string GetLiveTime(TaskModel task)
    {
        if (task.Status == EnumStatus.Active && task.TimeStart != default)
        {
            TimeSpan passed = string.IsNullOrEmpty(task.TimePassed) ? TimeSpan.Zero : TimeSpan.Parse(task.TimePassed);
            TimeSpan current = DateTime.Now - task.TimeStart;
            TimeSpan total = passed + current;
            return total.ToString(@"hh\:mm\:ss");
        }
        else
        {
            return string.IsNullOrEmpty(task.TimePassed) ? "00:00:00" : task.TimePassed;
        }
    }

    private async Task StartTask(TaskModel task)
    {
        task.Status = EnumStatus.Active;
        task.TimeStart = DateTime.Now;
        await ApiService.PutProtectedDataAsync<TaskModel>("/api/tasks/" + task.Id, task);
    }

    private async Task StopTask(TaskModel task)
    {
        task.Status = EnumStatus.InComplete;
        var existingTime = string.IsNullOrEmpty(task.TimePassed) ? TimeSpan.Zero : TimeSpan.Parse(task.TimePassed);
        task.TimePassed = (existingTime + (DateTime.Now - task.TimeStart)).ToString(@"hh\:mm\:ss");

        var taskTimerModel = new TaskTimerModel
        {
            StartTime = task.TimeStart,
            EndTime = DateTime.Now,
            TaskID = task.Id,
            UserID = Userid,
            DateTimeCreated = DateTime.Now
        };

        await ApiService.PutProtectedDataAsync<TaskModel>("/api/tasks/" + task.Id, task);
        await ApiService.PostProtectedDataAsync<TaskTimerModel>("/api/tasktimers/", taskTimerModel);
    }

    private void EditTask(long TaskId) => Navigation.NavigateTo($"editTask/{TaskId}");
    private void TaskHistory(long TaskId) => Navigation.NavigateTo($"tasks/history/{TaskId}");

    private async Task CompleteTask(TaskModel task)
    {
        task.Status = EnumStatus.Completed;
        task.Completed = true;
        await ApiService.PutProtectedDataAsync<TaskModel>("/api/tasks/" + task.Id, task);
    }

    public void Dispose()
    {
        cts?.Cancel();
        cts?.Dispose();
    }
}
